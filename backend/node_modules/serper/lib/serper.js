"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serper = void 0;
const errors_1 = require("./errors");
class Serper {
    constructor({ apiKey, timeout, basePath, cache }) {
        this.apiKey = apiKey;
        this.timeout = timeout !== null && timeout !== void 0 ? timeout : 10000;
        this.basePath = basePath !== null && basePath !== void 0 ? basePath : "https://google.serper.dev";
        this.doCache = cache !== null && cache !== void 0 ? cache : true;
        this.responseCache = {};
    }
    request(query, path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.apiKey)
                throw new errors_1.MissingApiKeyError();
            if (typeof query === "string") {
                return this.request({
                    q: query
                }, path);
            }
            const requestHash = JSON.stringify(Object.assign(Object.assign({}, query), { path }), Object.keys(Object.assign(Object.assign({}, query), { path })).sort());
            let response;
            if (!this.doCache || !this.responseCache[requestHash]) {
                response = yield fetch(`${this.basePath}/${path}`, {
                    method: "POST",
                    headers: {
                        "x-api-key": this.apiKey,
                        "content-type": "application/json"
                    },
                    body: JSON.stringify(query),
                    signal: AbortSignal.timeout(this.timeout)
                }).then((res) => res.json());
                this.responseCache[requestHash] = response;
            }
            else {
                console.log("Using cached response");
                response = this.responseCache[requestHash];
            }
            // TODO: Implement response object.
            const paginate = (amount, replace = false) => {
                var _a;
                const page = replace ? amount : ((_a = query.page) !== null && _a !== void 0 ? _a : 1) + amount;
                return this.request(Object.assign(Object.assign({}, query), { page: page > 1 ? page : 1 }), path);
            };
            response.nextPage = () => paginate(1);
            response.prevPage = () => paginate(-1);
            response.toPage = (page) => paginate(page, true);
            return response;
        });
    }
    search(query) {
        return this.request(query, "search");
    }
    news(query) {
        return this.request(query, "news");
    }
    images(query) {
        return this.request(query, "images");
    }
    videos(query) {
        return this.request(query, "videos");
    }
    places(query) {
        return this.request(query, "places");
    }
}
exports.Serper = Serper;
